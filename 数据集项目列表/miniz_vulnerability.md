# Miniz  æ¼æ´æ±‡æ€»è¡¨

## ğŸ“‹ æ¼æ´æ€»è§ˆè¡¨

| æ¼æ´ç¼–å· | æ¼æ´ç±»å‹ | ç›®æ ‡Fuzzer | ä¿®æ”¹æ–‡ä»¶ | å‡½æ•°å | è¡Œå· | è§¦å‘æ–¹å¼ | ç®€è¦æè¿° |
|:-------:|---------|-----------|---------|--------|------|---------|---------|
| **#1** | Use-After-Free | zip_fuzzer | miniz_zip.c | `mz_zip_mem_read_func` | ~925 | n > 32å­—èŠ‚ | åˆ†é…32å­—èŠ‚å †å†…å­˜â†’é‡Šæ”¾â†’å†™å…¥å·²é‡Šæ”¾å†…å­˜ |
| **#2** | Integer Overflow â†’ Heap Overflow | uncompress_fuzzer | miniz.c | `mz_inflate` | ~439 | avail_in > 100 | æ•´æ•°æº¢å‡ºå¯¼è‡´åˆ†é…å°ç¼“å†²åŒºâ†’å†™å…¥256å­—èŠ‚å¯¼è‡´å †æº¢å‡º |
| **#3** | Double Free | zip_fuzzer | miniz_zip.c | `mz_zip_reader_extract_to_mem_no_alloc` | ~1591 | è§£å‹å¤±è´¥ | é”™è¯¯è·¯å¾„ä¸Šå¯¹åŒä¸€å†…å­˜è¿›è¡Œä¸¤æ¬¡freeæ“ä½œ |
| **#4** | Division by Zero | compress_fuzzer | miniz_tdef.c | `TDEFL_RLE_PREV_CODE_SIZE` (å®) | ~294 | å®è¢«è°ƒç”¨ | åœ¨å®ä¸­æ‰§è¡Œ 100/0 å¯¼è‡´æµ®ç‚¹å¼‚å¸¸ |
| **#5** | Null Pointer Dereference | zip_fuzzer | miniz_zip.c | `mz_zip_file_stat_internal` | ~1210 | æ–‡ä»¶åé•¿åº¦ > 10 | æ˜¾å¼è®¾ç½®NULLæŒ‡é’ˆâ†’ç›´æ¥è§£å¼•ç”¨â†’SEGVå´©æºƒ |

---

## ğŸ“ è¯¦ç»†ä¿¡æ¯è¡¨

### æ¼æ´ #1: Use-After-Free (è¯»å–å‡½æ•°)

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #1 |
| **ç±»å‹** | Use-After-Free (UAF) |
| **ä¸¥é‡æ€§** | ğŸ”´ Critical |
| **Fuzzer** | zip_fuzzer |
| **æ–‡ä»¶** | miniz_zip.c |
| **å‡½æ•°** | `mz_zip_mem_read_func()` |
| **è¡Œå·** | ~925-932 |
| **è§¦å‘æ¡ä»¶** | ZIPæ–‡ä»¶è¯»å–ï¼Œn > 32å­—èŠ‚ï¼ˆå‡ ä¹æ‰€æœ‰ZIPæ–‡ä»¶ï¼‰ |
| **ä»£ç å˜æ›´** | +9è¡Œä»£ç  |
| **æœºåˆ¶** | 1. æ£€æŸ¥ n > 32<br>2. malloc(32) åˆ†é…å †å†…å­˜<br>3. memcpyå†™å…¥"test"<br>4. free()é‡Šæ”¾å†…å­˜<br>5. **å†™å…¥å·²é‡Šæ”¾å†…å­˜ temp[0]='X'** |
| **ASanæ£€æµ‹** | `heap-use-after-free on address 0x...` |
| **é¢„æœŸæ£€æµ‹æ—¶é—´** | < 5ç§’ |

**åŸå§‹ä»£ç **:

```c
static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
    memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
    return s;
}
```

**ä¿®æ”¹åä»£ç **:
```c
static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    /* VULNERABILITY 1 [zip_fuzzer]: Use-After-Free - allocate, free, then use */
    if (n > 32) {  /* Trigger on larger reads */
        char *temp = (char*)malloc(32);
        if (temp) {
            memcpy(temp, "test", 5);
            free(temp);  /* Free the memory */
            temp[0] = 'X';  /* Use after free - write to freed memory */
        }
    }
    size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
    memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
    return s;
}
```

---

### æ¼æ´ #2: æ•´æ•°æº¢å‡ºå¯¼è‡´å †æº¢å‡º

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #2 |
| **ç±»å‹** | Integer Overflow â†’ Heap Buffer Overflow |
| **ä¸¥é‡æ€§** | ğŸ”´ Critical |
| **Fuzzer** | uncompress_fuzzer |
| **æ–‡ä»¶** | miniz.c |
| **å‡½æ•°** | `mz_inflate()` |
| **è¡Œå·** | ~439-449 |
| **è§¦å‘æ¡ä»¶** | è¾“å…¥æ•°æ® avail_in > 100å­—èŠ‚ï¼ˆæ‰€æœ‰æ­£å¸¸å‹ç¼©æ•°æ®ï¼‰ |
| **ä»£ç å˜æ›´** | +13è¡Œä»£ç  |
| **æœºåˆ¶** | 1. æ£€æŸ¥ pStream->avail_in > 100<br>2. bad_size = 0xFFFFFFFFï¼ˆå¤§å€¼ï¼‰<br>3. bad_size = (bad_size+1) & 0xFFï¼ˆæº¢å‡ºåˆ°0-255ï¼‰<br>4. malloc(bad_size) åˆ†é…å°ç¼“å†²åŒº<br>5. **memsetå†™å…¥256å­—èŠ‚â†’å †æº¢å‡º** |
| **ASanæ£€æµ‹** | `heap-buffer-overflow on address 0x...` |
| **é¢„æœŸæ£€æµ‹æ—¶é—´** | < 30ç§’ |

**åŸå§‹ä»£ç **:
```c
int mz_inflate(mz_streamp pStream, int flush)
{
    inflate_state *pState;
    mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
    size_t in_bytes, out_bytes, orig_avail_in;
    tinfl_status status;

    if ((!pStream) || (!pStream->state))
        return MZ_STREAM_ERROR;
```

**ä¿®æ”¹åä»£ç **:
```c
int mz_inflate(mz_streamp pStream, int flush)
{
    inflate_state *pState;
    mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
    size_t in_bytes, out_bytes, orig_avail_in;
    tinfl_status status;

    /* VULNERABILITY 2 [uncompress_fuzzer]: Integer overflow causes small allocation */
    if (pStream && pStream->avail_in > 100) {
        /* Integer overflow: large value wraps to small value */
        size_t bad_size = (size_t)(0xFFFFFFFF);  /* Large value */
        bad_size = (bad_size + 1) & 0xFF;  /* Wraps to small value (0-255) */
        char *vuln_buf = (char*)malloc(bad_size);  /* Allocates small buffer */
        if (vuln_buf) {
            /* Write 256 bytes to small buffer - heap overflow */
            memset(vuln_buf, 'A', 256);
            free(vuln_buf);
        }
    }

    if ((!pStream) || (!pStream->state))
        return MZ_STREAM_ERROR;
```

---

### æ¼æ´ #3: åŒé‡é‡Šæ”¾ âœ…

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #3 |
| **ç±»å‹** | Double Free |
| **ä¸¥é‡æ€§** | ğŸ”´ Critical |
| **Fuzzer** | zip_fuzzer |
| **æ–‡ä»¶** | miniz_zip.c |
| **å‡½æ•°** | `mz_zip_reader_extract_to_mem_no_alloc()` |
| **è¡Œå·** | ~1591-1593 |
| **è§¦å‘æ¡ä»¶** | ZIPè§£å‹å¤±è´¥ï¼ˆstatus != TINFL_STATUS_DONEï¼‰ |
| **ä»£ç å˜æ›´** | +4è¡Œä»£ç  |
| **æœºåˆ¶** | 1. ç¬¬ä¸€æ¬¡é‡Šæ”¾ï¼šæ­£å¸¸è·¯å¾„ `free(pRead_buf)`<br>2. **ç¬¬äºŒæ¬¡é‡Šæ”¾**ï¼šé”™è¯¯è·¯å¾„å†æ¬¡ `free(pRead_buf)` |
| **ASanæ£€æµ‹** | `attempting double-free on 0x...` |
| **å®é™…æ£€æµ‹æ—¶é—´** | < 10ç§’ âœ… **å·²åœ¨v3/v4éªŒè¯** |
| **çŠ¶æ€** | âœ… **å·²éªŒè¯æˆåŠŸ** |

---

### æ¼æ´ #4: é™¤é›¶é”™è¯¯ âœ…

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #4 |
| **ç±»å‹** | Division by Zero (FPE) |
| **ä¸¥é‡æ€§** | ğŸ”´ Critical |
| **Fuzzer** | compress_fuzzer |
| **æ–‡ä»¶** | miniz_tdef.c |
| **å‡½æ•°** | `TDEFL_RLE_PREV_CODE_SIZE` å® |
| **è¡Œå·** | ~294-295 |
| **è§¦å‘æ¡ä»¶** | å‹ç¼©æ“ä½œè°ƒç”¨å®æ—¶ï¼ˆå¿…ç„¶è§¦å‘ï¼‰ |
| **ä»£ç å˜æ›´** | +2è¡Œä»£ç ï¼ˆå®å†…ï¼‰ |
| **æœºåˆ¶** | 1. å®è¢«è°ƒç”¨<br>2. `volatile int vuln_div = 0;`<br>3. **`100 / vuln_div` â†’ é™¤é›¶å¼‚å¸¸** |
| **æ£€æµ‹** | `Floating point exception (core dumped)` |
| **å®é™…æ£€æµ‹æ—¶é—´** | < 2åˆ†é’Ÿ âœ… **å·²åœ¨v4éªŒè¯** |
| **çŠ¶æ€** | âœ… **å·²éªŒè¯æˆåŠŸ** |

**åŸå§‹ä»£ç **:
```c
#define TDEFL_RLE_PREV_CODE_SIZE()                                                                                       \
    {                                                                                                                    \
        if (rle_repeat_count)                                                                                            \
        {                                                                                                                \
            if (rle_repeat_count < 3)                                                                                    \
            {                                                                                                            \
                d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
                while (rle_repeat_count--)                                                                               \
                    packed_code_sizes[num_packed_code_sizes++] = prev_code_size;                                         \
            }                                                                                                            \
            else                                                                                                         \
            {                                                                                                            \
                d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);                                        \
                packed_code_sizes[num_packed_code_sizes++] = 16;                                                         \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3);                           \
            }                                                                                                            \
            rle_repeat_count = 0;                                                                                        \
        }                                                                                                                \
    }
```

**ä¿®æ”¹åä»£ç **:
```c
#define TDEFL_RLE_PREV_CODE_SIZE()                                                                                       \
    {                                                                                                                    \
        /* VULNERABILITY 4 [compress_fuzzer]: Division by zero */                                                        \
        { volatile int vuln_div = 0; volatile int vuln_res = 100 / vuln_div; (void)vuln_res; }                          \
        if (rle_repeat_count)                                                                                            \
        {                                                                                                                \
            if (rle_repeat_count < 3)                                                                                    \
            {                                                                                                            \
                d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
                while (rle_repeat_count--)                                                                               \
                    packed_code_sizes[num_packed_code_sizes++] = prev_code_size;                                         \
            }                                                                                                            \
            else                                                                                                         \
            {                                                                                                            \
                d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);                                        \
                packed_code_sizes[num_packed_code_sizes++] = 16;                                                         \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3);                           \
            }                                                                                                            \
            rle_repeat_count = 0;                                                                                        \
        }                                                                                                                \
    }
```

---

### æ¼æ´ #5: ç©ºæŒ‡é’ˆè§£å¼•ç”¨

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #5 |
| **ç±»å‹** | Null Pointer Dereference |
| **ä¸¥é‡æ€§** | ğŸ”´ Critical |
| **Fuzzer** | zip_fuzzer |
| **æ–‡ä»¶** | miniz_zip.c |
| **å‡½æ•°** | `mz_zip_file_stat_internal()` |
| **è¡Œå·** | ~1210-1214 |
| **è§¦å‘æ¡ä»¶** | ZIPæ–‡ä»¶åé•¿åº¦ > 10å­—ç¬¦ï¼ˆå¤§å¤šæ•°ZIPæ–‡ä»¶ï¼‰ |
| **ä»£ç å˜æ›´** | +5è¡Œä»£ç  |
| **æœºåˆ¶** | 1. æ£€æŸ¥ n > 10ï¼ˆæ–‡ä»¶åé•¿åº¦ï¼‰<br>2. `char *null_ptr = NULL;` æ˜¾å¼è®¾ç½®ä¸ºNULL<br>3. **ç›´æ¥è§£å¼•ç”¨ `*null_ptr = 'X'`**<br>4. å†™å…¥åœ°å€0x0 â†’ SEGVå´©æºƒ |
| **ASanæ£€æµ‹** | `SEGV on unknown address 0x000000000000` |
| **é¢„æœŸæ£€æµ‹æ—¶é—´** | < 10ç§’ |

**åŸå§‹ä»£ç **:
```c
    /* Copy as much of the filename and comment as possible. */
    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
    memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
    pStat->m_filename[n] = '\0';
```

**ä¿®æ”¹åä»£ç **:
```c
    /* Copy as much of the filename and comment as possible. */
    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
    
    /* VULNERABILITY 5 [zip_fuzzer]: Null Pointer Dereference - dereference NULL pointer */
    if (n > 10) {
        char *null_ptr = NULL;  /* Explicitly set to NULL */
        /* Direct dereference without NULL check - immediate crash */
        *null_ptr = 'X';  /* Write to NULL address - SEGV */
    }
    
    memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
    pStat->m_filename[n] = '\0';
```

---

## ğŸ“Š ç»Ÿè®¡ä¿¡æ¯

### æŒ‰æ–‡ä»¶åˆ†ç±»

| æ–‡ä»¶ | æ¼æ´æ•°é‡ | æ¼æ´ç¼–å· |
|-----|---------|---------|
| **miniz_zip.c** | 3ä¸ª | #1, #3 âœ…, #5 |
| **miniz.c** | 1ä¸ª | #2 |
| **miniz_tdef.c** | 1ä¸ª | #4 âœ… |

### æŒ‰ç±»å‹åˆ†ç±»

| æ¼æ´ç±»å‹ | æ•°é‡ | æ¼æ´ç¼–å· | ASanæ£€æµ‹éš¾åº¦ |
|---------|-----|---------|------------|
| **Use-After-Free** | 1ä¸ª | #1 | ğŸŸ¢ ææ˜“ |
| **Double Free** | 1ä¸ª | #3 âœ… | ğŸŸ¢ ææ˜“ |
| **Integer Overflow â†’ Heap Overflow** | 1ä¸ª | #2 | ğŸŸ¢ ææ˜“ |
| **Division by Zero** | 1ä¸ª | #4 âœ… | ğŸŸ¢ ææ˜“ |
| **Null Pointer Dereference** | 1ä¸ª | #5 | ğŸŸ¢ ææ˜“ |

### æŒ‰Fuzzeråˆ†ç±»

| Fuzzer | æ¼æ´æ•°é‡ | æ¼æ´ç¼–å· |
|--------|---------|---------|
| **zip_fuzzer** | 3ä¸ª | #1, #3 âœ…, #5 |
| **uncompress_fuzzer** | 1ä¸ª | #2 |
| **compress_fuzzer** | 1ä¸ª | #4 âœ… |

### æŒ‰éªŒè¯çŠ¶æ€åˆ†ç±»

| çŠ¶æ€ | æ•°é‡ | æ¼æ´ç¼–å· |
|-----|-----|---------|
| âœ… **å·²éªŒè¯æˆåŠŸ** | 2ä¸ª | #3, #4 |
| ğŸ”„ **ç­‰å¾…éªŒè¯** | 3ä¸ª | #1, #2, #5 |

---

## ğŸ”§ ä»£ç ä¿®æ”¹ç»Ÿè®¡

```diff
 miniz.c      | 13 +++++++++++++  (æ¼æ´#2)
 miniz_tdef.c |  2 ++             (æ¼æ´#4 âœ…)
 miniz_zip.c  | 18 ++++++++++++++++++  (æ¼æ´#1, #3 âœ…, #5)
 ---
 3 files changed, 33 insertions(+)
```

### è¯¦ç»†è¡Œæ•°ç»Ÿè®¡

| æ¼æ´ | æ–°å¢è¡Œæ•° | ç±»å‹ |
|:---:|:-------:|-----|
| #1 | +9 | UAF |
| #2 | +13 | Int Overflow |
| #3 | +4 | Double Free âœ… |
| #4 | +2 | Div by Zero âœ… |
| #5 | +5 | Null Deref |
| **æ€»è®¡** | **+33** | **5ä¸ªæ¼æ´** |

---

## ğŸ¯ è§¦å‘æ¡ä»¶æ€»ç»“

| æ¼æ´ | è§¦å‘éš¾åº¦ | è§¦å‘æ¡ä»¶ | è§¦å‘æ¦‚ç‡ |
|:---:|---------|---------|---------|
| #1 | ğŸŸ¢ ææ˜“ | n > 32å­—èŠ‚ | ~100% (æ‰€æœ‰ZIPè¯»å–) |
| #2 | ğŸŸ¢ ææ˜“ | avail_in > 100 | ~100% (æ‰€æœ‰å‹ç¼©æ•°æ®) |
| #3 | ğŸŸ¢ ææ˜“ | è§£å‹å¤±è´¥ | ~80% (fuzzerä¼šè§¦å‘) âœ… |
| #4 | ğŸŸ¢ ææ˜“ | å®è¢«è°ƒç”¨ | ~100% (å‹ç¼©å¿…è°ƒç”¨) âœ… |
| #5 | ğŸŸ¢ ææ˜“ | æ–‡ä»¶å > 10å­—ç¬¦ | ~95% (å¤§å¤šæ•°ZIP) |

---

## ğŸ“ˆ é¢„æœŸæ£€æµ‹æ—¶é—´çº¿

| æ—¶é—´èŒƒå›´ | é¢„æœŸæ£€æµ‹æ¼æ´ | ç±»å‹ |
|---------|------------|------|
| **0-10ç§’** | #1, #3 âœ…, #5 | UAF, Double-Free, UAF |
| **10-30ç§’** | #2 | Integer Overflow |
| **30-120ç§’** | #4 âœ… | Division by Zero |
| **< 3åˆ†é’Ÿ** | **å…¨éƒ¨5ä¸ªæ¼æ´** | - |

---

## ğŸš€ å¿«é€Ÿå‚è€ƒ

### OSS-Fuzzæµ‹è¯•å‘½ä»¤

```bash
# è¿è¡Œæ‰€æœ‰fuzzer
python infra/helper.py run_fuzzer miniz zip_fuzzer -- -max_total_time=300 &
python infra/helper.py run_fuzzer miniz uncompress_fuzzer -- -max_total_time=300 &
python infra/helper.py run_fuzzer miniz compress_fuzzer -- -max_total_time=300 &
```

### æ£€æŸ¥å´©æºƒ

```bash
# æŒ‰æ¼æ´ç±»å‹æŸ¥æ‰¾
grep "heap-use-after-free" build/out/miniz/*.log     # æ¼æ´#1
grep "double-free" build/out/miniz/*.log             # æ¼æ´#3 âœ…
grep "heap-buffer-overflow.*256" build/out/miniz/*.log  # æ¼æ´#2
grep "Floating point" build/out/miniz/*.log          # æ¼æ´#4 âœ…
grep "SEGV on unknown address 0x000000000000" build/out/miniz/*.log  # æ¼æ´#5
```

### è¿˜åŸä»£ç 

```bash
cd miniz
git restore miniz.c miniz_zip.c miniz_tdef.c
git status
```

---

## âš ï¸ é‡è¦æé†’

1. âŒ **ä¸è¦æäº¤åˆ°ç”Ÿäº§ç¯å¢ƒ**
2. âœ… **ä»…ç”¨äºOSS-Fuzzæµ‹è¯•éªŒè¯**
3. ğŸ“ **æ‰€æœ‰æ¼æ´éƒ½æœ‰ `VULNERABILITY` æ ‡è®°**
4. ğŸ”’ **æµ‹è¯•å®ŒæˆååŠ¡å¿…è¿˜åŸä»£ç **
5. âœ… **æ¼æ´#3å’Œ#4å·²åœ¨ä¹‹å‰ç‰ˆæœ¬éªŒè¯æˆåŠŸ**

---

**æ—¥æœŸ**: 2025-11-21  
