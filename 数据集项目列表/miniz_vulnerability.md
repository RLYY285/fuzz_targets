# Miniz æ¼æ´æ±‡æ€»è¡¨

## ğŸ“‹ æ¼æ´æ€»è§ˆè¡¨

| æ¼æ´ç¼–å· | æ¼æ´ç±»å‹ | ç›®æ ‡Fuzzer | ä¿®æ”¹æ–‡ä»¶ | å‡½æ•°å | è¡Œå· | è§¦å‘æ–¹å¼ | ç®€è¦æè¿° |
|:-------:|---------|-----------|---------|--------|------|---------|---------|
| **#1** | Use-After-Free | zip_fuzzer | miniz_zip.c | `mz_zip_mem_read_func` | ~925 | n > 32å­—èŠ‚ | åˆ†é…32å­—èŠ‚â†’é‡Šæ”¾â†’å†™å…¥1æ¬¡ |
| **#2** | Integer Overflow â†’ Heap Overflow | uncompress_fuzzer | miniz.c | `mz_inflate` | ~439 | avail_in > 100 | æ•´æ•°æº¢å‡ºå¯¼è‡´åˆ†é…å°ç¼“å†²åŒºâ†’å†™å…¥256å­—èŠ‚å¯¼è‡´å †æº¢å‡º |
| **#3** | Double Free | zip_fuzzer | miniz_zip.c | `mz_zip_reader_extract_to_mem_no_alloc` | ~1591 | è§£å‹å¤±è´¥ | é”™è¯¯è·¯å¾„ä¸Šå¯¹åŒä¸€å†…å­˜è¿›è¡Œä¸¤æ¬¡freeæ“ä½œ |
| **#4** | Division by Zero | compress_fuzzer | miniz_tdef.c | `TDEFL_RLE_PREV_CODE_SIZE` (å®) | ~294 | å®è¢«è°ƒç”¨ | åœ¨å®ä¸­æ‰§è¡Œ 100/0 å¯¼è‡´æµ®ç‚¹å¼‚å¸¸ |
| **#5** | Null Pointer Dereference | zip_fuzzer | miniz_zip.c | `mz_zip_file_stat_internal` | ~1209 | æ–‡ä»¶åé•¿åº¦ > 10 | volatileè¯»å–NULLâ†’å†™å…¥NULLâ†’å»¶è¿Ÿå´©æºƒ |

---

## ğŸ“ è¯¦ç»†ä¿¡æ¯è¡¨

### æ¼æ´ #1: Use-After-Free (è¯»å–å‡½æ•°)

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #1 |
| **ç±»å‹** | Use-After-Free (UAF) |
| **ä¸¥é‡æ€§** | ğŸ”´ Critical |
| **Fuzzer** | zip_fuzzer |
| **æ–‡ä»¶** | miniz_zip.c |
| **å‡½æ•°** | `mz_zip_mem_read_func()` |
| **è¡Œå·** | ~925 |
| **è§¦å‘æ¡ä»¶** | ZIPæ–‡ä»¶è¯»å–ï¼Œn > 32å­—èŠ‚ï¼ˆå‡ ä¹æ‰€æœ‰ZIPæ–‡ä»¶ï¼‰ |
| **ä»£ç å˜æ›´** | +8è¡Œä»£ç (ç®€åŒ–ç‰ˆ) |
| **æœºåˆ¶** | 1. æ£€æŸ¥ n > 32<br>2. `malloc(32)` åˆ†é…å†…å­˜<br>3. `memcpy(temp, "test", 5)` å†™å…¥æ•°æ®<br>4. `free(temp)` é‡Šæ”¾å†…å­˜<br>5. **è®¿é—®å·²é‡Šæ”¾å†…å­˜**ï¼š`temp[0]='X'`<br>6. AddressSanitizeræ£€æµ‹ |
| **ASanæ£€æµ‹** | `heap-use-after-free` |
| **é¢„æœŸæ£€æµ‹æ—¶é—´** | < 10ç§’ |
| **å®é™…æ£€æµ‹æ—¶é—´** | ğŸ”„ **å¾…æµ‹è¯•** |
| **çŠ¶æ€** | âœ… **ä»£ç å·²æ¿€æ´»ï¼Œç­‰å¾…æµ‹è¯•** |

**åŸå§‹ä»£ç **:
```c
static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
    memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
    return s;
}
```

**ä¿®æ”¹åä»£ç ï¼ˆç®€åŒ–ç‰ˆï¼‰**:
```c
static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    /* VULNERABILITY 1 [zip_fuzzer]: Use-After-Free - allocate, free, then use */
    if (n > 32) {  /* Trigger on larger reads */
        char *temp = (char*)malloc(32);
        if (temp) {
            memcpy(temp, "test", 5);
            free(temp);  /* Free the memory */
            temp[0] = 'X';  /* Use after free - write to freed memory */
        }
    }
    size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
    memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
    return s;
}
```

---

### æ¼æ´ #2: æ•´æ•°æº¢å‡ºå¯¼è‡´å †æº¢å‡º

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #2 |
| **ç±»å‹** | Integer Overflow â†’ Heap Buffer Overflow |
| **ä¸¥é‡æ€§** | ğŸ”´ Critical |
| **Fuzzer** | uncompress_fuzzer |
| **æ–‡ä»¶** | miniz.c |
| **å‡½æ•°** | `mz_inflate()` |
| **è¡Œå·** | ~439-449 |
| **è§¦å‘æ¡ä»¶** | è¾“å…¥æ•°æ® avail_in > 100å­—èŠ‚ï¼ˆæ‰€æœ‰æ­£å¸¸å‹ç¼©æ•°æ®ï¼‰ |
| **ä»£ç å˜æ›´** | +10è¡Œä»£ç  |
| **æœºåˆ¶** | 1. æ£€æŸ¥ pStream->avail_in > 100<br>2. bad_size = 0xFFFFFFFFï¼ˆå¤§å€¼ï¼‰<br>3. bad_size = (bad_size+1) & 0xFFï¼ˆæº¢å‡ºåˆ°0-255ï¼‰<br>4. malloc(bad_size) åˆ†é…å°ç¼“å†²åŒº<br>5. **memsetå†™å…¥256å­—èŠ‚â†’å †æº¢å‡º** |
| **ASanæ£€æµ‹** | `heap-buffer-overflow on address 0x...` |
| **é¢„æœŸæ£€æµ‹æ—¶é—´** | < 30ç§’ |
| **å®é™…æ£€æµ‹æ—¶é—´** | ğŸ”„ **å¾…æµ‹è¯•** |
| **çŠ¶æ€** | âœ… **ä»£ç å·²æ¿€æ´»ï¼Œç­‰å¾…æµ‹è¯•** |

**åŸå§‹ä»£ç **:
```c
int mz_inflate(mz_streamp pStream, int flush)
{
    inflate_state *pState;
    mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
    size_t in_bytes, out_bytes, orig_avail_in;
    tinfl_status status;

    if ((!pStream) || (!pStream->state))
        return MZ_STREAM_ERROR;
```

**ä¿®æ”¹åä»£ç **:
```c
int mz_inflate(mz_streamp pStream, int flush)
{
    inflate_state *pState;
    mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
    size_t in_bytes, out_bytes, orig_avail_in;
    tinfl_status status;

    /* VULNERABILITY 2 [uncompress_fuzzer]: Integer overflow causes small allocation */
    if (pStream && pStream->avail_in > 100) {
        /* Integer overflow: large value wraps to small value */
        size_t bad_size = (size_t)(0xFFFFFFFF);  /* Large value */
        bad_size = (bad_size + 1) & 0xFF;  /* Wraps to small value (0-255) */
        char *vuln_buf = (char*)malloc(bad_size);  /* Allocates small buffer */
        if (vuln_buf) {
            /* Write 256 bytes to small buffer - heap overflow */
            memset(vuln_buf, 'A', 256);
            free(vuln_buf);
        }
    }

    if ((!pStream) || (!pStream->state))
        return MZ_STREAM_ERROR;
```

---

### æ¼æ´ #3: Double Free

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #3 |
| **ç±»å‹** | Double Free |
| **ä¸¥é‡æ€§** | ğŸ”´ Critical |
| **Fuzzer** | zip_fuzzer |
| **æ–‡ä»¶** | miniz_zip.c |
| **å‡½æ•°** | `mz_zip_reader_extract_to_mem_no_alloc()` |
| **è¡Œå·** | ~1589-1591 |
| **è§¦å‘æ¡ä»¶** | ZIPè§£å‹å¤±è´¥ï¼ˆæ„é€ ç•¸å½¢ZIPï¼‰ |
| **ä»£ç å˜æ›´** | +3è¡Œä»£ç  |
| **æœºåˆ¶** | 1. æ­£å¸¸è·¯å¾„å·²ç»freeä¸€æ¬¡<br>2. é”™è¯¯è·¯å¾„æ£€æŸ¥ `status != TINFL_STATUS_DONE`<br>3. å¯¹åŒä¸€å—å†…å­˜å†æ¬¡è°ƒç”¨ `pZip->m_pFree()` |
| **ASanæ£€æµ‹** | `attempting double-free on 0x...` |
| **é¢„æœŸæ£€æµ‹æ—¶é—´** | < 1åˆ†é’Ÿ |
| **å®é™…æ£€æµ‹æ—¶é—´** | ğŸ”„ **å¾…æµ‹è¯•** |
| **çŠ¶æ€** | âœ… **ä»£ç å·²æ¿€æ´»ï¼Œç­‰å¾…æµ‹è¯•** |

**åŸå§‹ä»£ç **:
```c
if (status != TINFL_STATUS_DONE)
{
    mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
    return MZ_FALSE;
}
```

**ä¿®æ”¹åä»£ç **:
```c
/* VULNERABILITY 3 [zip_fuzzer]: Double Free */
if (status != TINFL_STATUS_DONE && pRead_buf != NULL)
    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

if (status != TINFL_STATUS_DONE)
{
    mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
    return MZ_FALSE;
}
```

---

### æ¼æ´ #4: Division by Zero

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #4 |
| **ç±»å‹** | Division by Zero (FPE) |
| **ä¸¥é‡æ€§** | ğŸŸ  High |
| **Fuzzer** | compress_fuzzer |
| **æ–‡ä»¶** | miniz_tdef.c |
| **å‡½æ•°/ä½ç½®** | `TDEFL_RLE_PREV_CODE_SIZE` å®å®šä¹‰ |
| **è¡Œå·** | ~294-295 |
| **è§¦å‘æ¡ä»¶** | å®è¢«è°ƒç”¨æ—¶ï¼ˆå‹ç¼©è¿‡ç¨‹ä¸­ï¼‰ |
| **ä»£ç å˜æ›´** | +2è¡Œä»£ç  |
| **æœºåˆ¶** | 1. åœ¨å®å®šä¹‰ä¸­æ³¨å…¥ volatile å˜é‡<br>2. `volatile int vuln_div = 0;`<br>3. `volatile int vuln_res = 100 / vuln_div;`<br>4. è§¦å‘é™¤é›¶å¼‚å¸¸ |
| **æ£€æµ‹æ–¹å¼** | SIGFPE (Floating Point Exception) |
| **é¢„æœŸæ£€æµ‹æ—¶é—´** | < 30ç§’ |
| **å®é™…æ£€æµ‹æ—¶é—´** | ğŸ”„ **å¾…æµ‹è¯•** |
| **çŠ¶æ€** | âœ… **ä»£ç å·²æ¿€æ´»ï¼Œç­‰å¾…æµ‹è¯•** |

**åŸå§‹ä»£ç **:
```c
#define TDEFL_RLE_PREV_CODE_SIZE() \
    { /* ... å®å†…å®¹ ... */ }
```

**ä¿®æ”¹åä»£ç **:
```c
#define TDEFL_RLE_PREV_CODE_SIZE() \
    { volatile int vuln_div = 0; volatile int vuln_res = 100 / vuln_div; \
      /* VULNERABILITY 4 [compress_fuzzer]: Division by Zero */ \
      /* ... åŸæœ‰å®å†…å®¹ ... */ }
```

---

### æ¼æ´ #5: Null Pointer Dereference

| å±æ€§ | è¯¦æƒ… |
|-----|------|
| **ç¼–å·** | #5 |
| **ç±»å‹** | Null Pointer Dereference |
| **ä¸¥é‡æ€§** | ğŸ”´ Critical |
| **Fuzzer** | zip_fuzzer |
| **æ–‡ä»¶** | miniz_zip.c |
| **å‡½æ•°** | `mz_zip_file_stat_internal()` |
| **è¡Œå·** | ~1209-1217 |
| **è§¦å‘æ¡ä»¶** | æ–‡ä»¶åé•¿åº¦ > 10å­—ç¬¦ |
| **ä»£ç å˜æ›´** | +8è¡Œä»£ç (æ”¹è¿›ç‰ˆ) |
| **æœºåˆ¶** | 1. å®šä¹‰ `mz_uint filename_len` å˜é‡<br>2. æ£€æŸ¥ filename_len > 10<br>3. `char *null_ptr = NULL;` æ˜¾å¼è®¾ç½®ä¸ºNULL<br>4. **volatileè¯»å– `volatile char x = *null_ptr`**<br>5. **å†™å…¥NULL `*null_ptr = 'X'`** ç ´åæ•°æ®ç»“æ„<br>6. `(void)x` é˜²æ­¢ä¼˜åŒ–<br>7. åç»­è°ƒç”¨å´©æºƒäº `mz_zip_get_cdh()` |
| **ASanæ£€æµ‹** | `unknown-crash on address 0x000000000001` |
| **é¢„æœŸæ£€æµ‹æ—¶é—´** | < 1ç§’ |
| **å®é™…æ£€æµ‹æ—¶é—´** | **< 1ç§’(ç§å­é˜¶æ®µ)** âœ… **å·²éªŒè¯æˆåŠŸ** |
| **å´©æºƒæ–‡ä»¶** | crash-a264d43db3453530c7877f401b77a3d0323d2bec |
| **çŠ¶æ€** | âœ… **å·²éªŒè¯æˆåŠŸ** |

**åŸå§‹ä»£ç **:
```c
static mz_bool mz_zip_file_stat_internal(/* ... */)
{
    /* ... å‡½æ•°å†…å®¹ ... */
}
```

**ä¿®æ”¹åä»£ç ï¼ˆæ”¹è¿›ç‰ˆï¼‰**:
```c
static mz_bool mz_zip_file_stat_internal(/* ... */)
{
    mz_uint filename_len = /* ... */;
    
    /* VULNERABILITY 5: Null Pointer Dereference - force crash */
    if (filename_len > 10) {
        char *null_ptr = NULL;
        volatile char x = *null_ptr;  /* Read from NULL */
        *null_ptr = 'X';  /* Write to NULL - corrupt structure */
        (void)x;  /* Prevent optimization */
    }
    
    /* ... åŸæœ‰ä»£ç ï¼Œåç»­è°ƒç”¨ä¼šå´©æºƒ ... */
}
```

---

## ğŸ“Š æµ‹è¯•çŠ¶æ€æ€»ç»“

| æ¼æ´ | Fuzzer | é¢„æœŸæ£€æµ‹æ—¶é—´ | å®é™…æ£€æµ‹æ—¶é—´ | çŠ¶æ€ |
|:---:|--------|-------------|-------------|:----:|
| #1 | zip_fuzzer | < 10ç§’ | ğŸ”„ å¾…æµ‹è¯• | âœ… å·²æ¿€æ´» |
| #2 | uncompress_fuzzer | < 30ç§’ | ğŸ”„ å¾…æµ‹è¯• | âœ… å·²æ¿€æ´» |
| #3 | zip_fuzzer | < 1åˆ†é’Ÿ | ğŸ”„ å¾…æµ‹è¯• | âœ… å·²æ¿€æ´» |
| #4 | compress_fuzzer | < 30ç§’ | ğŸ”„ å¾…æµ‹è¯• | âœ… å·²æ¿€æ´» |
| #5 | zip_fuzzer | < 1ç§’ | **< 1ç§’** âœ… | âœ… **éªŒè¯æˆåŠŸ** |

**æµ‹è¯•ç¯å¢ƒ**ï¼šOSS-Fuzz + libFuzzer + AddressSanitizer

**å…³é”®å‘ç°**ï¼š
- âœ… æ¼æ´#5ï¼ˆæ”¹è¿›ç‰ˆï¼‰åœ¨ç§å­é˜¶æ®µå³è¢«æ£€æµ‹åˆ°ï¼ˆ<1ç§’ï¼‰
- âœ… æ‰€æœ‰æ¼æ´ä»£ç å‡å·²æ¿€æ´»
- ğŸ”„ æ¼æ´#1-#4å¾…è¿›ä¸€æ­¥æµ‹è¯•éªŒè¯

