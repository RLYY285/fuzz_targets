## 📝 libxml2 漏洞数据集报告 (v2.9.10)

### 📋 漏洞总览表 (Ground Truth)

| 漏洞编号 | 漏洞类型 | 目标Fuzzer | 修改文件 | 函数名 | 触发机制 |
| :-------: | :--- | :--- | :--- | :--- | :--- |
| **\#1** | **Stack Buffer Overflow** | xml\_fuzzer | parser.c | `xmlParseName` | 超长 XML 标签名 |
| **\#2** | **Double Free** | xml\_fuzzer | tree.c | `xmlFreeNode` | 节点清理时重复 `free` |
| **\#3** | **Use-After-Free (Read)** | xml\_fuzzer | tree.c | `xmlUnlinkNode` | 解链后访问已删除节点的指针 |
| **\#4** | **Null Pointer Deref** | xml\_fuzzer | tree.c | `xmlAddChild` | 移除 `parent` 判空检查 |
| **\#5** | **Format String** | xml\_fuzzer | error.c | `xmlGenericError` | 错误地使用不可控变量作为格式化字符串 |

-----

## 📝 详细信息表

### 漏洞 \#1: Stack Buffer Overflow (超长标签名)

| 属性 | 详情 |
|-----|------|
| **编号** | \#1 |
| **类型** | Stack Buffer Overflow |
| **严重性** | 🔴 Critical |
| **文件** | parser.c |
| **函数** | `xmlParseName` (约 1312 行) |
| **ASan检测** | `stack-buffer-overflow on address 0x...` |
| **机制** | 利用 Fuzzer 生成的超长标签名，使其超出程序员预设的日志缓冲区。 |

**修改后代码示例 (parser.c):**

```c
/* 植入位置: xmlParseName 函数开头，变量声明之后 */
    /* VULNERABILITY 1: Stack Buffer Overflow */
    char debug_buf[16]; /* 16 byte stack buffer */
    if (ctxt->input->cur - ctxt->input->base > 15) { 
        /* 标签名长度超出 15 字节时触发溢出 */
        sprintf(debug_buf, "Name length: %ld", ctxt->input->cur - ctxt->input->base); 
    }
    // ... 原本的 ASCII accelerator 代码 ...
```

### 漏洞 \#2: Double Free (节点清理)

| 属性 | 详情 |
|-----|------|
| **编号** | \#2 |
| **类型** | Double Free |
| **严重性** | 🔴 Critical |
| **文件** | tree.c |
| **函数** | `xmlFreeNode` (约 1103 行) |
| **ASan检测** | `attempting double-free on 0x...` |
| **机制** | 程序员错误地重复调用 `xmlFree` 释放同一内存指针。 |

**修改后代码示例 (tree.c):**

```c
/* 植入位置: xmlFreeNode 函数内，释放 node->name 的代码块中 */
    if (node->name != NULL) {
        xmlFree((xmlChar *) node->name);
        /* VULNERABILITY 2: Double Free */
        xmlFree((xmlChar *) node->name); /* <-- 重复释放！ */
    }
```

### 漏洞 \#4: Null Pointer Dereference (移除安全检查)

| 属性 | 详情 |
|-----|------|
| **编号** | \#4 |
| **类型** | Null Pointer Dereference |
| **严重性** | 🔴 Critical |
| **文件** | tree.c |
| **函数** | `xmlAddChild` (约 1475 行) |
| **ASan检测** | `SEGV on unknown address 0x000000000000` |
| **机制** | 删除 `parent == NULL` 的安全检查，强制程序访问空指针的成员 (`parent->doc`)。 |

**修改后代码示例 (tree.c):**

```c
/* 植入位置: xmlAddChild 函数开头 */
xmlNodePtr xmlAddChild(xmlNodePtr parent, xmlNodePtr cur) {
    xmlNodePtr prev;

    if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {
        // ... debug message ...
        /* VULNERABILITY 4: Null Pointer Deref (安全检查被删除) */
	// return(NULL); /* <-- 原本的安全返回语句被注释掉或删除 */
    }
    // ... 程序继续，并在后续代码中访问 parent->doc 导致崩溃 ...
```

-----

## 模块回顾：最终集成流程总结

你在 `libxml2` 上的成功依赖于以下 4 个关键步骤的正确执行：

| 关键操作 | 文件/位置 | 目的 |
| :--- | :--- | :--- |
| **1. Harness 准备** | `xml_fuzzer.c` | 创建 `xmlReadMemory` Fuzzer 入口，确保 LibFuzzer 可以调用核心解析函数。 |
| **2. Autotools 启动** | `build.sh` | 插入 **`./autogen.sh`** 步骤，用于生成缺失的 `./configure` 脚本。 |
| **3. Python 禁用** | `build.sh` (`./configure`行) | 添加 **`--without-python`** 参数，解决与新版 Python 的兼容性问题。 |
| **4. 链接器修正** | `build.sh` (链接行) | 添加 **`-L.libs`** 旗标，强制链接器找到 Libtool 隐藏的静态库 (`libxml2.a`)，解决了 `cannot find -lxml2` 错误。 |
